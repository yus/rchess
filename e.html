<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Chess ¬∑ RULES FIXED ¬∑ Pawn promotion, Bishop colors, King escape</title>
    <style>
        * { box-sizing: border-box; user-select: none; }
        body {
            font-family: 'Segoe UI', Roboto, system-ui;
            background: #1e4d1e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 16px;
        }
        .game-wrapper {
            background: #2d5a2d;
            padding: 25px 25px 20px;
            border-radius: 28px;
            box-shadow: 0 20px 30px rgba(0,0,0,0.6);
            max-width: 750px;
            width: fit-content;
        }
        .board-container {
            display: flex;
            justify-content: center;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            border: 5px solid #4a3c31;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 15px rgba(0,0,0,0.5);
        }
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            cursor: pointer;
            transition: 0.08s;
            position: relative;
        }
        .square.light { background: #eed9b2; }
        .square.dark { background: #b58863; }
        .square.selected {
            outline: 4px solid #ffb703;
            outline-offset: -3px;
            filter: brightness(1.1);
            z-index: 2;
            background: #ffe68f !important;
        }
        .square.valid-move {
            cursor: pointer;
            position: relative;
        }
        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: rgba(0, 200, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            border: 2px solid white;
        }
        .square.capture-move::after {
            background: rgba(200, 50, 50, 0.6);
            border-radius: 0;
            transform: rotate(45deg);
            width: 25px;
            height: 25px;
        }
        .square.last-move {
            box-shadow: inset 0 0 0 4px #4290ff;
        }
        .square.check-square {
            background: rgba(255, 0, 0, 0.3) !important;
        }
        .backrank-pawn {
            position: relative;
            display: inline-block;
        }
        .backrank-pawn::after {
            content: '¬π';
            position: absolute;
            top: -8px;
            right: -12px;
            font-size: 22px;
            font-weight: bold;
            color: #cc0000;
            text-shadow: 1px 1px 0 white;
        }
        .info-panel {
            margin-top: 20px;
            color: white;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        .turn-box {
            background: #4a3c31;
            padding: 10px 25px;
            border-radius: 40px;
            font-size: 22px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid #ebc28b;
        }
        .turn-box span {
            font-size: 32px;
            line-height: 1;
        }
        button {
            background: #f5c542;
            border: none;
            padding: 12px 28px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 40px;
            cursor: pointer;
            transition: 0.2s;
            box-shadow: 0 5px 0 #b57c00;
            border: 1px solid #ffe28a;
        }
        button:hover {
            background: #ffd966;
            transform: translateY(-2px);
            box-shadow: 0 7px 0 #b57c00;
        }
        button:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #b57c00;
        }
        .rules-history {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 18px;
            margin-top: 20px;
        }
        .rule-box, .history-box {
            background: #3b5e3b;
            border-radius: 18px;
            padding: 15px 18px;
            color: #f0f0d0;
            border: 2px solid #6f8c5d;
            box-shadow: inset 0 2px 5px #1e3a1e;
        }
        .rule-box h3, .history-box h3 {
            margin: 0 0 8px 0;
            color: #ffde9e;
            font-size: 20px;
            border-bottom: 2px dotted #aab57a;
            padding-bottom: 4px;
        }
        .rule-box ul {
            margin: 8px 0 0;
            padding-left: 22px;
        }
        .rule-box li {
            margin: 8px 0;
            font-size: 15px;
        }
        .rule-box .critical {
            color: #ffb4a2;
            font-weight: 600;
            background: #5d3a2e;
            padding: 5px 10px;
            border-radius: 30px;
            list-style: none;
            margin-left: -22px;
        }
        .history-box {
            max-height: 180px;
            overflow-y: auto;
            font-size: 15px;
            background: #2d4d2d;
            user-select: text;
            cursor: text;
        }
        .history-entry {
            padding: 4px 6px;
            border-bottom: 1px solid #6f8260;
            font-family: 'Courier New', monospace;
        }
        .check-warning {
            background: #b22222;
            color: white;
            padding: 6px 15px;
            border-radius: 30px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        .game-over {
            background: #4a3c31;
            color: gold;
            font-size: 24px;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 40px;
        }
        .promotion-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #4a3c31;
            border: 4px solid #ebc28b;
            border-radius: 20px;
            padding: 25px;
            display: flex;
            gap: 20px;
            z-index: 100;
            box-shadow: 0 10px 30px black;
        }
        .promotion-piece {
            font-size: 60px;
            cursor: pointer;
            padding: 10px;
            background: #b58863;
            border-radius: 15px;
            transition: 0.2s;
        }
        .promotion-piece:hover {
            transform: scale(1.1);
            background: #eed9b2;
        }
        .copy-button {
            background: #4a6b4a;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .copy-button:hover {
            background: #5d825d;
        }
        .warning-message {
            color: #ffaa00;
            font-weight: bold;
            margin-top: 5px;
        }
        .bishop-warning {
            background: #8a2be2;
            color: white;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 14px;
            margin-left: 10px;
        }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; } }
    </style>
</head>
<body>
<div class="game-wrapper">
    <div class="board-container">
        <div class="board" id="chessboard"></div>
    </div>

    <div class="info-panel">
        <div class="turn-box" id="turnDisplay">
            <span>‚ö™</span> Your turn (White)
        </div>
        <button onclick="resetGame()">üé≤ New Random Game</button>
    </div>

    <div class="rules-history">
        <div class="rule-box">
            <h3>‚ö° Rchess rules</h3>
            <ul>
                <li>‚ôú All 16 pieces random on 1st+2nd rank</li>
                <li>üî¥ <strong>Back‚Äërank pawn</strong> (marked <span style="color:#ff8888">¬π</span>) ‚Üí only 1 square</li>
                <li>‚úÖ 2nd-rank pawns: can move 1 or 2 squares (then become normal)</li>
                <li>üëë CHECK RULE ‚Äî King on 2nd rank is ONLY in check if a DIRECT opponent major (‚ôú‚ôû‚ôù‚ôõ) attacks it.</li>
                <li>üëë FIRST PASS ‚Äî If king on 2nd rank in check, ANY piece can move once to resolve.</li>
                <li>‚¨ÜÔ∏è Pawn promotion ‚Äî Choose ‚ôõ‚ôú‚ôû‚ôù on last rank</li>
                <li><strong>‚ôù BISHOP COLOR RULE</strong> ‚Äî Two bishops of same side must be on opposite colors</li>
                <li><strong>‚ôú ROOK/‚ôû KNIGHT COLOR RULE</strong> ‚Äî Couples start on opposite colored squares</li>
                <li>üö´ No castling ¬∑ üíÄ Capturing king wins instantly</li>
            </ul>
        </div>
        <div class="history-box" id="historyBox">
            <h3>üìú Move history <button class="copy-button" onclick="copyHistory()">üìã Copy</button></h3>
            <div id="movesList"></div>
        </div>
    </div>
</div>

<script>
(function() {
    // ----- GAME STATE -----
    let board = Array(8).fill().map(() => Array(8).fill(null));
    let currentPlayer = 'white';
    let humanColor = 'white';
    let gameOver = false;
    let winner = null;
    
    let selectedSquare = null;
    let validMoves = [];
    let moveHistory = [];
    let lastMove = null;
    
    // Promotion state
    let pendingPromotion = null;
    
    // Special rule tracking
    let whiteKingStartRow = null;
    let blackKingStartRow = null;
    let usedFirstPassWhite = false;
    let usedFirstPassBlack = false;
    
    // Track pawns that have used double move
    let pawnDoubleMoveUsed = new Set();

    // Bishop color tracking
    let whiteBishopColors = { light: false, dark: false };
    let blackBishopColors = { light: false, dark: false };
    
    // Rook/Knight color tracking for couples
    let whiteRookColors = [];
    let blackRookColors = [];
    let whiteKnightColors = [];
    let blackKnightColors = [];

    // Piece symbols
    const symbols = {
        white: { rook:'‚ôú', knight:'‚ôû', bishop:'‚ôù', queen:'‚ôõ', king:'‚ôö', pawn:'‚ôü' },
        black: { rook:'‚ôñ', knight:'‚ôò', bishop:'‚ôó', queen:'‚ôï', king:'‚ôî', pawn:'‚ôô' }
    };

    // Major pieces for check rule
    const majorPieces = ['rook', 'knight', 'bishop', 'queen'];

    // ----- UTILITY -----
    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // Get square color (light or dark)
    function getSquareColor(row, col) {
        return (row + col) % 2 === 0 ? 'light' : 'dark';
    }

    // Check if position is valid for couples (rooks and knights)
    function validateCoupleColors() {
        whiteRookColors = [];
        blackRookColors = [];
        whiteKnightColors = [];
        blackKnightColors = [];
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let piece = board[r][c];
                if (!piece) continue;
                
                let squareColor = getSquareColor(r, c);
                
                if (piece.pieceType === 'rook') {
                    if (piece.color === 'white') {
                        whiteRookColors.push(squareColor);
                    } else {
                        blackRookColors.push(squareColor);
                    }
                } else if (piece.pieceType === 'knight') {
                    if (piece.color === 'white') {
                        whiteKnightColors.push(squareColor);
                    } else {
                        blackKnightColors.push(squareColor);
                    }
                } else if (piece.pieceType === 'bishop') {
                    if (piece.color === 'white') {
                        whiteBishopColors[squareColor] = true;
                    } else {
                        blackBishopColors[squareColor] = true;
                    }
                }
            }
        }
        
        // Check couples (should have one light and one dark)
        let valid = true;
        
        if (whiteRookColors.length === 2) {
            if (whiteRookColors[0] === whiteRookColors[1]) {
                console.warn("White rooks on same color!");
                valid = false;
            }
        }
        
        if (blackRookColors.length === 2) {
            if (blackRookColors[0] === blackRookColors[1]) {
                console.warn("Black rooks on same color!");
                valid = false;
            }
        }
        
        if (whiteKnightColors.length === 2) {
            if (whiteKnightColors[0] === whiteKnightColors[1]) {
                console.warn("White knights on same color!");
                valid = false;
            }
        }
        
        if (blackKnightColors.length === 2) {
            if (blackKnightColors[0] === blackKnightColors[1]) {
                console.warn("Black knights on same color!");
                valid = false;
            }
        }
        
        // Check bishops
        if (whiteBishopColors.light && whiteBishopColors.dark) {
            console.warn("White bishops on both colors!");
            valid = false;
        }
        if (blackBishopColors.light && blackBishopColors.dark) {
            console.warn("Black bishops on both colors!");
            valid = false;
        }
        
        return valid;
    }

    // Check if placing a piece would violate couple color rule
    function wouldViolateCoupleColor(row, col, piece) {
        let squareColor = getSquareColor(row, col);
        
        if (piece.pieceType === 'bishop') {
            if (piece.color === 'white') {
                if (squareColor === 'light' && whiteBishopColors.dark) return true;
                if (squareColor === 'dark' && whiteBishopColors.light) return true;
            } else {
                if (squareColor === 'light' && blackBishopColors.dark) return true;
                if (squareColor === 'dark' && blackBishopColors.light) return true;
            }
        } else if (piece.pieceType === 'rook') {
            let colors = piece.color === 'white' ? whiteRookColors : blackRookColors;
            // If we already have a rook, check if it's on same color
            if (colors.length === 1) {
                if (colors[0] === squareColor) return true;
            }
        } else if (piece.pieceType === 'knight') {
            let colors = piece.color === 'white' ? whiteKnightColors : blackKnightColors;
            if (colors.length === 1) {
                if (colors[0] === squareColor) return true;
            }
        }
        return false;
    }

    // ----- BOARD SETUP WITH ALL COLOR RULES -----
    function createRandomBoard() {
        let attempts = 0;
        let validPosition = false;
        
        while (!validPosition && attempts < 500) {
            attempts++;
            humanColor = Math.random() < 0.5 ? 'white' : 'black';
            
            // Clear board
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    board[r][c] = null;
                }
            }

            // Reset tracking
            whiteBishopColors = { light: false, dark: false };
            blackBishopColors = { light: false, dark: false };
            whiteRookColors = [];
            blackRookColors = [];
            whiteKnightColors = [];
            blackKnightColors = [];

            const majorTypes = ['rook','knight','bishop','queen','king','bishop','knight','rook'];
            const pawnTypes = Array(8).fill('pawn');
            
            let whitePool = shuffleArray([...majorTypes, ...pawnTypes]);
            let blackPool = shuffleArray([...majorTypes, ...pawnTypes]);

            // Place white with color validation
            let whiteValid = true;
            for (let c = 0; c < 8; c++) {
                // Row 0
                let piece1 = {
                    type: symbols.white[whitePool[c]],
                    pieceType: whitePool[c],
                    color: 'white',
                    startingRow: 0,
                    hasMoved: false,
                    id: `white_${whitePool[c]}_0_${c}_${Date.now()}_${Math.random()}`
                };
                
                // Check color rule for this placement
                if (wouldViolateCoupleColor(0, c, piece1)) {
                    whiteValid = false;
                    break;
                }
                
                board[0][c] = piece1;
                updatePieceColorTracking(piece1, 0, c);
                
                // Row 1
                let piece2 = {
                    type: symbols.white[whitePool[c+8]],
                    pieceType: whitePool[c+8],
                    color: 'white',
                    startingRow: 1,
                    hasMoved: false,
                    id: `white_${whitePool[c+8]}_1_${c}_${Date.now()}_${Math.random()}`
                };
                
                if (wouldViolateCoupleColor(1, c, piece2)) {
                    whiteValid = false;
                    break;
                }
                
                board[1][c] = piece2;
                updatePieceColorTracking(piece2, 1, c);
            }
            
            if (!whiteValid) continue;
            
            // Place black with color validation
            let blackValid = true;
            for (let c = 0; c < 8; c++) {
                // Row 7
                let piece1 = {
                    type: symbols.black[blackPool[c]],
                    pieceType: blackPool[c],
                    color: 'black',
                    startingRow: 7,
                    hasMoved: false,
                    id: `black_${blackPool[c]}_7_${c}_${Date.now()}_${Math.random()}`
                };
                
                if (wouldViolateCoupleColor(7, c, piece1)) {
                    blackValid = false;
                    break;
                }
                
                board[7][c] = piece1;
                updatePieceColorTracking(piece1, 7, c);
                
                // Row 6
                let piece2 = {
                    type: symbols.black[blackPool[c+8]],
                    pieceType: blackPool[c+8],
                    color: 'black',
                    startingRow: 6,
                    hasMoved: false,
                    id: `black_${blackPool[c+8]}_6_${c}_${Date.now()}_${Math.random()}`
                };
                
                if (wouldViolateCoupleColor(6, c, piece2)) {
                    blackValid = false;
                    break;
                }
                
                board[6][c] = piece2;
                updatePieceColorTracking(piece2, 6, c);
            }
            
            if (!blackValid) continue;

            // Store king start rows
            whiteKingStartRow = null;
            blackKingStartRow = null;
            for (let r = 0; r < 2; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c]?.pieceType === 'king') whiteKingStartRow = r;
                }
            }
            for (let r = 6; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c]?.pieceType === 'king') blackKingStartRow = r;
                }
            }

            // Final validation
            if (!areKingsAdjacent(board) && validateCoupleColors()) {
                validPosition = true;
            }
        }

        pawnDoubleMoveUsed.clear();
        usedFirstPassWhite = false;
        usedFirstPassBlack = false;
        gameOver = false;
        winner = null;
        lastMove = null;
        currentPlayer = 'white';
    }

    function updatePieceColorTracking(piece, row, col) {
        let squareColor = getSquareColor(row, col);
        
        if (piece.pieceType === 'bishop') {
            if (piece.color === 'white') {
                whiteBishopColors[squareColor] = true;
            } else {
                blackBishopColors[squareColor] = true;
            }
        } else if (piece.pieceType === 'rook') {
            if (piece.color === 'white') {
                whiteRookColors.push(squareColor);
            } else {
                blackRookColors.push(squareColor);
            }
        } else if (piece.pieceType === 'knight') {
            if (piece.color === 'white') {
                whiteKnightColors.push(squareColor);
            } else {
                blackKnightColors.push(squareColor);
            }
        }
    }

    // ----- KING ADJACENCY CHECK -----
    function areKingsAdjacent(boardState) {
        let whiteKing = null;
        let blackKing = null;
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let piece = boardState[r][c];
                if (piece && piece.pieceType === 'king') {
                    if (piece.color === 'white') whiteKing = {row: r, col: c};
                    else blackKing = {row: r, col: c};
                }
            }
        }
        
        if (!whiteKing || !blackKing) return false;
        
        let rowDiff = Math.abs(whiteKing.row - blackKing.row);
        let colDiff = Math.abs(whiteKing.col - blackKing.col);
        
        return rowDiff <= 1 && colDiff <= 1;
    }

    // ----- BACK-RANK PAWN CHECK -----
    function isBackRankPawn(piece) {
        if (!piece || piece.pieceType !== 'pawn') return false;
        return (piece.color === 'white' && piece.startingRow === 0) ||
               (piece.color === 'black' && piece.startingRow === 7);
    }

    // ----- MOVE GENERATION -----
    function getValidMoves(row, col) {
        const piece = board[row][col];
        if (!piece) return [];

        let moves = [];

        if (piece.pieceType === 'pawn') {
            const dir = piece.color === 'white' ? 1 : -1;
            const backRank = isBackRankPawn(piece);
            const pawnId = piece.id;
            const hasUsedDoubleMove = pawnDoubleMoveUsed.has(pawnId);

            // Forward 1
            if (row + dir >= 0 && row + dir < 8 && !board[row + dir][col]) {
                moves.push({row: row + dir, col: col});
            }

            // Forward 2 - only for 2nd rank pawns (row 1 for white, row 6 for black)
            let isSecondRankPawn = (piece.color === 'white' && piece.startingRow === 1) ||
                                   (piece.color === 'black' && piece.startingRow === 6);
            
            if (isSecondRankPawn && !piece.hasMoved && !hasUsedDoubleMove) {
                if (row + 2*dir >= 0 && row + 2*dir < 8 && 
                    !board[row + dir][col] && !board[row + 2*dir][col]) {
                    moves.push({row: row + 2*dir, col: col});
                }
            }

            // Captures
            for (let dc of [-1, 1]) {
                let nc = col + dc;
                if (nc >= 0 && nc < 8 && row + dir >= 0 && row + dir < 8) {
                    let target = board[row + dir][nc];
                    if (target && target.color !== piece.color) {
                        moves.push({row: row + dir, col: nc});
                    }
                }
            }
        }

        // ROOK / QUEEN
        if (piece.pieceType === 'rook' || piece.pieceType === 'queen') {
            const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
            for (let [dr, dc] of dirs) {
                let r = row + dr, c = col + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    if (!board[r][c]) {
                        moves.push({row: r, col: c});
                    } else {
                        if (board[r][c].color !== piece.color) {
                            moves.push({row: r, col: c});
                        }
                        break;
                    }
                    r += dr; c += dc;
                }
            }
        }
        
        // BISHOP / QUEEN
        if (piece.pieceType === 'bishop' || piece.pieceType === 'queen') {
            const dirs = [[1,1], [1,-1], [-1,1], [-1,-1]];
            for (let [dr, dc] of dirs) {
                let r = row + dr, c = col + dc;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    if (!board[r][c]) {
                        moves.push({row: r, col: c});
                    } else {
                        if (board[r][c].color !== piece.color) {
                            moves.push({row: r, col: c});
                        }
                        break;
                    }
                    r += dr; c += dc;
                }
            }
        }
        
        // KNIGHT
        if (piece.pieceType === 'knight') {
            const jumps = [[2,1], [2,-1], [-2,1], [-2,-1], [1,2], [1,-2], [-1,2], [-1,-2]];
            for (let [dr, dc] of jumps) {
                let r = row + dr, c = col + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    if (!board[r][c] || board[r][c].color !== piece.color) {
                        moves.push({row: r, col: c});
                    }
                }
            }
        }
        
        // KING
        if (piece.pieceType === 'king') {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    let r = row + dr, c = col + dc;
                    if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                        // King cannot move into check
                        if (!board[r][c] || board[r][c].color !== piece.color) {
                            // We'll filter check moves later
                            moves.push({row: r, col: c});
                        }
                    }
                }
            }
        }

        // Filter moves
        moves = moves.filter(m => {
            let target = board[m.row][m.col];
            
            // 1. Can't capture own king
            if (target && target.pieceType === 'king') return false;
            
            // 2. Can't make kings adjacent
            if (wouldMoveMakeKingsAdjacent(row, col, m.row, m.col)) return false;
            
            // 3. For couples, check color rule
            if (target === null) {
                if (wouldViolateCoupleColor(m.row, m.col, piece)) return false;
            }
            
            // 4. Can't move into check (king safety)
            if (wouldMoveLeaveKingInCheck(row, col, m.row, m.col, piece.color)) return false;
            
            return true;
        });

        return moves;
    }

    // Check if a move would make kings adjacent
    function wouldMoveMakeKingsAdjacent(fromRow, fromCol, toRow, toCol) {
        let tempBoard = [];
        for (let r = 0; r < 8; r++) {
            tempBoard[r] = [];
            for (let c = 0; c < 8; c++) {
                tempBoard[r][c] = board[r][c] ? {...board[r][c]} : null;
            }
        }
        
        let piece = tempBoard[fromRow][fromCol];
        tempBoard[toRow][toCol] = {...piece, hasMoved: true};
        tempBoard[fromRow][fromCol] = null;
        
        let whiteKing = null;
        let blackKing = null;
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let p = tempBoard[r][c];
                if (p && p.pieceType === 'king') {
                    if (p.color === 'white') whiteKing = {row: r, col: c};
                    else blackKing = {row: r, col: c};
                }
            }
        }
        
        if (!whiteKing || !blackKing) return false;
        
        let rowDiff = Math.abs(whiteKing.row - blackKing.row);
        let colDiff = Math.abs(whiteKing.col - blackKing.col);
        
        return rowDiff <= 1 && colDiff <= 1;
    }

    // Check if a move would leave king in check
    function wouldMoveLeaveKingInCheck(fromRow, fromCol, toRow, toCol, color) {
        let tempBoard = [];
        for (let r = 0; r < 8; r++) {
            tempBoard[r] = [];
            for (let c = 0; c < 8; c++) {
                tempBoard[r][c] = board[r][c] ? {...board[r][c]} : null;
            }
        }
        
        let piece = tempBoard[fromRow][fromCol];
        tempBoard[toRow][toCol] = {...piece, hasMoved: true};
        tempBoard[fromRow][fromCol] = null;
        
        // Find king after move
        let kingRow, kingCol;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (tempBoard[r][c]?.pieceType === 'king' && tempBoard[r][c]?.color === color) {
                    kingRow = r;
                    kingCol = c;
                    break;
                }
            }
        }
        
        if (kingRow === undefined) return true;
        
        // Check if any enemy piece attacks the king
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let attacker = tempBoard[r][c];
                if (attacker && attacker.color !== color) {
                    if (isPieceAttackingSquareInBoard(tempBoard, r, c, kingRow, kingCol)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // Check if piece attacks square in given board state
    function isPieceAttackingSquareInBoard(boardState, pieceRow, pieceCol, targetRow, targetCol) {
        let piece = boardState[pieceRow][pieceCol];
        if (!piece) return false;
        
        if (piece.pieceType === 'pawn') {
            let dir = piece.color === 'white' ? 1 : -1;
            return (targetRow === pieceRow + dir && Math.abs(targetCol - pieceCol) === 1);
        } else if (piece.pieceType === 'knight') {
            let dr = Math.abs(targetRow - pieceRow);
            let dc = Math.abs(targetCol - pieceCol);
            return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
        } else if (piece.pieceType === 'king') {
            return Math.abs(targetRow - pieceRow) <= 1 && Math.abs(targetCol - pieceCol) <= 1;
        } else {
            // Sliding pieces
            if (pieceRow === targetRow) {
                // Horizontal
                let step = targetCol > pieceCol ? 1 : -1;
                for (let c = pieceCol + step; c !== targetCol; c += step) {
                    if (boardState[pieceRow][c]) return false;
                }
                return true;
            } else if (pieceCol === targetCol) {
                // Vertical
                let step = targetRow > pieceRow ? 1 : -1;
                for (let r = pieceRow + step; r !== targetRow; r += step) {
                    if (boardState[r][pieceCol]) return false;
                }
                return true;
            } else if (Math.abs(targetRow - pieceRow) === Math.abs(targetCol - pieceCol)) {
                // Diagonal
                let rStep = targetRow > pieceRow ? 1 : -1;
                let cStep = targetCol > pieceCol ? 1 : -1;
                let r = pieceRow + rStep;
                let c = pieceCol + cStep;
                while (r !== targetRow && c !== targetCol) {
                    if (boardState[r][c]) return false;
                    r += rStep;
                    c += cStep;
                }
                return true;
            }
        }
        return false;
    }

    // ----- CHECK DETECTION -----
    function isSquareAttackedByMajor(row, col, attackerColor) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let p = board[r][c];
                if (p && p.color === attackerColor && majorPieces.includes(p.pieceType)) {
                    if (isPieceAttackingSquare(r, c, row, col)) return true;
                }
            }
        }
        return false;
    }

    function isSquareAttackedByAny(row, col, attackerColor) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let p = board[r][c];
                if (p && p.color === attackerColor) {
                    if (isPieceAttackingSquare(r, c, row, col)) return true;
                }
            }
        }
        return false;
    }

    function isPieceAttackingSquare(pieceRow, pieceCol, targetRow, targetCol) {
        return isPieceAttackingSquareInBoard(board, pieceRow, pieceCol, targetRow, targetCol);
    }

    function kingPos(color) {
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (board[r][c]?.pieceType === 'king' && board[r][c]?.color === color) {
                    return {row: r, col: c};
                }
            }
        }
        return null;
    }

    function isInCheck(color) {
        let k = kingPos(color);
        if (!k) return false;
        
        let isSecondRank = (color === 'white' && k.row === 1) || (color === 'black' && k.row === 6);
        
        if (isSecondRank) {
            return isSquareAttackedByMajor(k.row, k.col, color === 'white' ? 'black' : 'white');
        } else {
            return isSquareAttackedByAny(k.row, k.col, color === 'white' ? 'black' : 'white');
        }
    }

    // Check if king has any escape squares (for checkmate detection)
    function kingHasEscapeSquares(color) {
        let k = kingPos(color);
        if (!k) return false;
        
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                let r = k.row + dr;
                let c = k.col + dc;
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    // Square must be empty or contain enemy piece
                    let target = board[r][c];
                    if (!target || target.color !== color) {
                        // Check if this square is attacked
                        if (!isSquareAttackedByAny(r, c, color === 'white' ? 'black' : 'white')) {
                            return true; // Found escape square
                        }
                    }
                }
            }
        }
        return false;
    }

    // Check if position is checkmate
    function isCheckmate(color) {
        if (!isInCheck(color)) return false;
        
        // Check if any piece can move to get out of check
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let piece = board[r][c];
                if (piece && piece.color === color) {
                    let moves = getValidMoves(r, c);
                    if (moves.length > 0) {
                        return false; // Found a move
                    }
                }
            }
        }
        
        // Also check if king can escape
        if (kingHasEscapeSquares(color)) return false;
        
        return true;
    }

    // ----- KING CAPTURE CHECK -----
    function checkForKingCapture() {
        let whiteKingExists = false;
        let blackKingExists = false;
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let piece = board[r][c];
                if (piece?.pieceType === 'king') {
                    if (piece.color === 'white') whiteKingExists = true;
                    else blackKingExists = true;
                }
            }
        }
        
        if (!whiteKingExists) {
            gameOver = true;
            winner = 'black';
        } else if (!blackKingExists) {
            gameOver = true;
            winner = 'white';
        }
        
        return gameOver;
    }

    // ----- PROMOTION -----
    function showPromotionDialog(from, to, piece) {
        pendingPromotion = { from, to, piece };
        
        let dialog = document.createElement('div');
        dialog.className = 'promotion-dialog';
        dialog.id = 'promotionDialog';
        
        let pieces = ['queen', 'rook', 'knight', 'bishop'];
        let symbols_map = {
            queen: piece.color === 'white' ? '‚ôõ' : '‚ôï',
            rook: piece.color === 'white' ? '‚ôú' : '‚ôñ',
            knight: piece.color === 'white' ? '‚ôû' : '‚ôò',
            bishop: piece.color === 'white' ? '‚ôù' : '‚ôó'
        };
        
        pieces.forEach(pType => {
            let div = document.createElement('div');
            div.className = 'promotion-piece';
            div.textContent = symbols_map[pType];
            div.onclick = () => completePromotion(pType);
            dialog.appendChild(div);
        });
        
        document.body.appendChild(dialog);
        renderBoard();
    }

    function completePromotion(newPieceType) {
        if (!pendingPromotion) return;
        
        let { from, to, piece } = pendingPromotion;
        
        // Check color rules for promotion
        let tempPiece = {...piece, pieceType: newPieceType};
        if (wouldViolateCoupleColor(to.row, to.col, tempPiece)) {
            alert(`Cannot promote to ${newPieceType} - would violate color rule!`);
            return;
        }
        
        // Update piece type
        let newSymbol = piece.color === 'white' ? symbols.white[newPieceType] : symbols.black[newPieceType];
        board[to.row][to.col].pieceType = newPieceType;
        board[to.row][to.col].type = newSymbol;
        
        // Update tracking
        updatePieceColorTracking(board[to.row][to.col], to.row, to.col);
        
        // Record promotion in history
        let lastEntry = moveHistory[moveHistory.length - 1];
        if (lastEntry) {
            moveHistory[moveHistory.length - 1] += `=${newPieceType[0].toUpperCase()}`;
        }
        
        document.getElementById('promotionDialog')?.remove();
        pendingPromotion = null;
        
        updateHistoryDisplay();
        renderBoard();
    }

    // ----- APPLY MOVE -----
    function applyMove(from, to, isFirstPass = false) {
        let piece = board[from.row][from.col];
        if (!piece) return false;

        // Track double move for pawns
        if (piece.pieceType === 'pawn' && Math.abs(to.row - from.row) === 2) {
            pawnDoubleMoveUsed.add(piece.id);
        }

        // Record move
        let fromCol = String.fromCharCode(97 + from.col);
        let toCol = String.fromCharCode(97 + to.col);
        let capture = board[to.row][to.col] ? 'x' : '';
        let moveText = `${piece.type} ${fromCol}${from.row+1}${capture}${toCol}${to.row+1}`;
        if (isFirstPass) moveText = '‚ú® ' + moveText;
        moveHistory.push(moveText);
        
        // Store last move
        lastMove = { from, to };
        
        // Move piece
        board[to.row][to.col] = {
            ...piece,
            hasMoved: true,
            id: piece.id
        };
        board[from.row][from.col] = null;

        // Update tracking
        whiteBishopColors = { light: false, dark: false };
        blackBishopColors = { light: false, dark: false };
        whiteRookColors = [];
        blackRookColors = [];
        whiteKnightColors = [];
        blackKnightColors = [];
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let p = board[r][c];
                if (p) updatePieceColorTracking(p, r, c);
            }
        }

        // Check for promotion
        if (piece.pieceType === 'pawn') {
            if ((piece.color === 'white' && to.row === 7) || (piece.color === 'black' && to.row === 0)) {
                showPromotionDialog(from, to, piece);
            }
        }

        updateHistoryDisplay();
        return true;
    }

    function updateHistoryDisplay() {
        let historyDiv = document.getElementById('movesList');
        historyDiv.innerHTML = moveHistory.slice(-15).map(h => 
            `<div class="history-entry">${h}</div>`
        ).join('');
    }

    // ----- FIRST-PASS RULE -----
    function firstPassAllowed(color) {
        if (color === 'white') {
            if (usedFirstPassWhite) return false;
            if (whiteKingStartRow !== 1) return false;
            return isInCheck('white');
        } else {
            if (usedFirstPassBlack) return false;
            if (blackKingStartRow !== 6) return false;
            return isInCheck('black');
        }
    }

    // ----- HUMAN MOVE HANDLER -----
    function tryHumanMove(from, to) {
        if (gameOver) return false;
        if (pendingPromotion) return false;
        
        let piece = board[from.row][from.col];
        if (!piece || piece.color !== humanColor) return false;

        let moves = getValidMoves(from.row, from.col);
        let isValid = moves.some(m => m.row === to.row && m.col === to.col);

        // First-pass rule
        if (!isValid && firstPassAllowed(humanColor)) {
            if (wouldMoveMakeKingsAdjacent(from.row, from.col, to.row, to.col)) {
                return false;
            }
            
            if (humanColor === 'white') usedFirstPassWhite = true;
            else usedFirstPassBlack = true;
            
            applyMove(from, to, true);
            
            if (checkForKingCapture()) {
                renderBoard();
                return true;
            }
            
            currentPlayer = (humanColor === 'white' ? 'black' : 'white');
            return true;
        }

        if (!isValid) return false;

        applyMove(from, to);
        
        if (checkForKingCapture()) {
            renderBoard();
            return true;
        }
        
        currentPlayer = (humanColor === 'white' ? 'black' : 'white');
        return true;
    }

    // ----- AI MOVE (with proper check/checkmate detection) -----
    function computerMove() {
        if (gameOver) return;
        if (pendingPromotion) return;
        if (currentPlayer === humanColor) return;
        
        let aiColor = humanColor === 'white' ? 'black' : 'white';
        
        // Check if AI is in checkmate
        if (isCheckmate(aiColor)) {
            gameOver = true;
            winner = humanColor;
            renderBoard();
            return;
        }
        
        // If AI is in check, must get out of check
        let inCheck = isInCheck(aiColor);
        
        // Collect all possible moves
        let allMoves = [];
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let piece = board[r][c];
                if (piece && piece.color === aiColor) {
                    let moves = getValidMoves(r, c);
                    for (let m of moves) {
                        allMoves.push({
                            from: {row: r, col: c},
                            to: m,
                            pieceType: piece.pieceType,
                            isCapture: board[m.row][m.col] !== null,
                            piece: piece
                        });
                    }
                }
            }
        }

        if (allMoves.length === 0) {
            // No moves - checkmate or stalemate
            if (inCheck) {
                gameOver = true;
                winner = humanColor;
            }
            renderBoard();
            return;
        }

        // Filter safe moves (don't leave king in check)
        let safeMoves = allMoves.filter(m => {
            if (wouldMoveLeaveKingInCheck(m.from.row, m.from.col, m.to.row, m.to.col, aiColor)) return false;
            if (wouldMoveMakeKingsAdjacent(m.from.row, m.from.col, m.to.row, m.to.col)) return false;
            
            // For empty square moves, check color rules
            if (!board[m.to.row][m.to.col]) {
                if (wouldViolateCoupleColor(m.to.row, m.to.col, m.piece)) return false;
            }
            
            return true;
        });
        
        // If in check, only safe moves are allowed
        if (inCheck) {
            if (safeMoves.length === 0) {
                // Checkmate
                gameOver = true;
                winner = humanColor;
                renderBoard();
                return;
            }
            allMoves = safeMoves;
        } else {
            // Prefer safe moves
            if (safeMoves.length > 0) {
                allMoves = safeMoves;
            }
        }
        
        if (allMoves.length === 0) return;
        
        // Prioritize captures, then checks, then random
        let captures = allMoves.filter(m => m.isCapture);
        let checks = allMoves.filter(m => wouldMoveGiveCheck(m.from, m.to, aiColor));
        
        let selected;
        if (captures.length > 0) {
            selected = captures[Math.floor(Math.random() * captures.length)];
        } else if (checks.length > 0) {
            selected = checks[Math.floor(Math.random() * checks.length)];
        } else {
            selected = allMoves[Math.floor(Math.random() * allMoves.length)];
        }

        // Execute move
        let piece = board[selected.from.row][selected.from.col];
        
        // Track double move for pawns
        if (piece.pieceType === 'pawn' && Math.abs(selected.to.row - selected.from.row) === 2) {
            pawnDoubleMoveUsed.add(piece.id);
        }
        
        let fromCol = String.fromCharCode(97 + selected.from.col);
        let toCol = String.fromCharCode(97 + selected.to.col);
        let capture = board[selected.to.row][selected.to.col] ? 'x' : '';
        moveHistory.push(`üñ•Ô∏è ${piece.type} ${fromCol}${selected.from.row+1}${capture}${toCol}${selected.to.row+1}`);
        
        lastMove = { from: selected.from, to: selected.to };
        
        board[selected.to.row][selected.to.col] = {...piece, hasMoved: true};
        board[selected.from.row][selected.from.col] = null;

        // Update tracking
        whiteBishopColors = { light: false, dark: false };
        blackBishopColors = { light: false, dark: false };
        whiteRookColors = [];
        blackRookColors = [];
        whiteKnightColors = [];
        blackKnightColors = [];
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let p = board[r][c];
                if (p) updatePieceColorTracking(p, r, c);
            }
        }

        // Check for promotion
        if (piece.pieceType === 'pawn') {
            if ((piece.color === 'white' && selected.to.row === 7) || (piece.color === 'black' && selected.to.row === 0)) {
                // Auto-queen for AI
                let newPieceType = 'queen';
                let newSymbol = piece.color === 'white' ? symbols.white[newPieceType] : symbols.black[newPieceType];
                board[selected.to.row][selected.to.col].pieceType = newPieceType;
                board[selected.to.row][selected.to.col].type = newSymbol;
                moveHistory[moveHistory.length - 1] += '=Q';
            }
        }
        
        updateHistoryDisplay();
        
        if (checkForKingCapture()) {
            renderBoard();
            return;
        }
        
        currentPlayer = humanColor;
        renderBoard();
    }
    
    // Check if move would give check
    function wouldMoveGiveCheck(from, to, color) {
        let tempBoard = [];
        for (let r = 0; r < 8; r++) {
            tempBoard[r] = [];
            for (let c = 0; c < 8; c++) {
                tempBoard[r][c] = board[r][c] ? {...board[r][c]} : null;
            }
        }
        
        let piece = tempBoard[from.row][from.col];
        tempBoard[to.row][to.col] = {...piece, hasMoved: true};
        tempBoard[from.row][from.col] = null;
        
        let opponentColor = color === 'white' ? 'black' : 'white';
        let opponentKing = null;
        
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (tempBoard[r][c]?.pieceType === 'king' && tempBoard[r][c]?.color === opponentColor) {
                    opponentKing = {row: r, col: c};
                    break;
                }
            }
        }
        
        if (!opponentKing) return false;
        
        // Check if any of AI's pieces attack the king
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let attacker = tempBoard[r][c];
                if (attacker && attacker.color === color) {
                    if (isPieceAttackingSquareInBoard(tempBoard, r, c, opponentKing.row, opponentKing.col)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // ----- RENDER BOARD -----
    function renderBoard() {
        const boardEl = document.getElementById('chessboard');
        boardEl.innerHTML = '';
        
        let rows = [0,1,2,3,4,5,6,7];
        if (humanColor === 'black') {
            rows = [7,6,5,4,3,2,1,0];
        }
        
        for (let r of rows) {
            for (let c = 0; c < 8; c++) {
                let square = document.createElement('div');
                square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                square.dataset.row = r;
                square.dataset.col = c;

                let piece = board[r][c];
                if (piece) {
                    let span = document.createElement('span');
                    span.textContent = piece.type;
                    if (isBackRankPawn(piece)) {
                        span.classList.add('backrank-pawn');
                    }
                    square.appendChild(span);
                }

                // Highlight selected
                if (selectedSquare && selectedSquare.row === r && selectedSquare.col === c) {
                    square.classList.add('selected');
                }

                // Highlight valid moves
                if (validMoves.some(m => m.row === r && m.col === c)) {
                    square.classList.add('valid-move');
                    if (board[r][c]) {
                        square.classList.add('capture-move');
                    }
                }
                
                // Highlight last move
                if (lastMove && ((lastMove.from.row === r && lastMove.from.col === c) || 
                                 (lastMove.to.row === r && lastMove.to.col === c))) {
                    square.classList.add('last-move');
                }
                
                // Highlight king in check
                if (piece && piece.pieceType === 'king' && isInCheck(piece.color)) {
                    square.classList.add('check-square');
                }

                square.addEventListener('click', () => handleSquareClick(r, c));
                boardEl.appendChild(square);
            }
        }

        // Update turn display
        let turnSpan = document.getElementById('turnDisplay');
        
        if (gameOver) {
            let winnerText = winner === humanColor ? 'YOU WIN! üéâ' : 'Computer wins ü§ñ';
            if (winner === 'draw') winnerText = 'Draw ü§ù';
            turnSpan.innerHTML = `<span>${winner === 'white' ? '‚ö™' : '‚ö´'}</span> ${winnerText}`;
            return;
        }
        
        if (pendingPromotion) {
            turnSpan.innerHTML = `<span>‚¨ÜÔ∏è</span> Choose promotion piece`;
            return;
        }
        
        // Add warnings for color rule violations
        let warning = '';
        if ((whiteBishopColors.light && whiteBishopColors.dark) ||
            (blackBishopColors.light && blackBishopColors.dark) ||
            (whiteRookColors.length === 2 && whiteRookColors[0] === whiteRookColors[1]) ||
            (blackRookColors.length === 2 && blackRookColors[0] === blackRookColors[1]) ||
            (whiteKnightColors.length === 2 && whiteKnightColors[0] === whiteKnightColors[1]) ||
            (blackKnightColors.length === 2 && blackKnightColors[0] === blackKnightColors[1])) {
            warning = '<span class="bishop-warning">‚ö†Ô∏è Color rule violation!</span>';
        }
        
        if (currentPlayer === humanColor) {
            let checkText = isInCheck(humanColor) ? ' ¬∑ <span class="check-warning">CHECK</span>' : '';
            turnSpan.innerHTML = `<span>${humanColor === 'white' ? '‚ö™' : '‚ö´'}</span> Your turn (${humanColor === 'white' ? 'White' : 'Black'})${checkText} ${warning}`;
        } else {
            turnSpan.innerHTML = `<span>${humanColor === 'white' ? '‚ö´' : '‚ö™'}</span> Computer (${humanColor === 'white' ? 'Black' : 'White'}) thinking... ${warning}`;
            setTimeout(() => {
                computerMove();
                renderBoard();
            }, 400);
        }
    }

    // ----- CLICK HANDLER -----
    function handleSquareClick(row, col) {
        if (gameOver) return;
        if (pendingPromotion) return;
        if (currentPlayer !== humanColor) return;

        if (selectedSquare === null) {
            let piece = board[row][col];
            if (piece && piece.color === humanColor) {
                selectedSquare = {row, col};
                validMoves = getValidMoves(row, col);
                renderBoard();
            }
        } else {
            let moved = tryHumanMove(selectedSquare, {row, col});
            selectedSquare = null;
            validMoves = [];
            renderBoard();
            
            if (!moved) {
                let piece = board[row][col];
                if (piece && piece.color === humanColor) {
                    selectedSquare = {row, col};
                    validMoves = getValidMoves(row, col);
                    renderBoard();
                }
            }
        }
    }

    // ----- COPY HISTORY -----
    window.copyHistory = function() {
        let historyText = moveHistory.join('\n');
        navigator.clipboard.writeText(historyText).then(() => {
            alert('History copied to clipboard!');
        }).catch(() => {
            let textarea = document.createElement('textarea');
            textarea.value = historyText;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            alert('History copied!');
        });
    };

    // ----- RESET -----
    window.resetGame = function() {
        if (pendingPromotion) {
            document.getElementById('promotionDialog')?.remove();
            pendingPromotion = null;
        }
        createRandomBoard();
        currentPlayer = 'white';
        selectedSquare = null;
        validMoves = [];
        moveHistory = [];
        lastMove = null;
        updateHistoryDisplay();
        renderBoard();
    };

    // Initialize
    createRandomBoard();
    renderBoard();
})();
</script>
</body>
</html>
