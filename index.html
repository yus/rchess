<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Chess ¬∑ vs Computer</title>
    <style>
        * { box-sizing: border-box; user-select: none; }
        body {
            font-family: 'Segoe UI', Roboto, system-ui;
            background: #1e4d1e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 16px;
        }
        .game-wrapper {
            background: #2d5a2d;
            padding: 25px 25px 20px;
            border-radius: 28px;
            box-shadow: 0 20px 30px rgba(0,0,0,0.6);
            max-width: 750px;
            width: fit-content;
        }
        .board-container {
            display: flex;
            justify-content: center;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            border: 5px solid #4a3c31;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 15px rgba(0,0,0,0.5);
        }
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            cursor: pointer;
            transition: 0.08s;
            position: relative;
        }
        .square.light { background: #eed9b2; }
        .square.dark { background: #b58863; }
        .square.selected {
            outline: 4px solid #ffb703;
            outline-offset: -3px;
            filter: brightness(1.1);
            z-index: 2;
        }
        .square.valid-move {
            cursor: pointer;
            position: relative;
        }
        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: rgba(0, 180, 0, 0.45);
            border-radius: 50%;
            pointer-events: none;
            border: 2px solid rgba(255,255,255,0.5);
        }
        .square:active {
            transform: scale(0.98);
        }
        .backrank-pawn {
            position: relative;
            display: inline-block;
        }
        .backrank-pawn::after {
            content: '¬π';
            position: absolute;
            top: -8px;
            right: -12px;
            font-size: 22px;
            font-weight: bold;
            color: #cc0000;
            text-shadow: 1px 1px 0 white;
        }
        .info-panel {
            margin-top: 20px;
            color: white;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        .turn-box {
            background: #4a3c31;
            padding: 10px 25px;
            border-radius: 40px;
            font-size: 22px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid #ebc28b;
        }
        .turn-box span {
            font-size: 32px;
            line-height: 1;
        }
        button {
            background: #f5c542;
            border: none;
            padding: 12px 28px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 40px;
            cursor: pointer;
            transition: 0.2s;
            box-shadow: 0 5px 0 #b57c00;
            border: 1px solid #ffe28a;
        }
        button:hover {
            background: #ffd966;
            transform: translateY(-2px);
            box-shadow: 0 7px 0 #b57c00;
        }
        button:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #b57c00;
        }
        .rules-history {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 18px;
            margin-top: 20px;
        }
        .rule-box, .history-box {
            background: #3b5e3b;
            border-radius: 18px;
            padding: 15px 18px;
            color: #f0f0d0;
            border: 2px solid #6f8c5d;
            box-shadow: inset 0 2px 5px #1e3a1e;
        }
        .rule-box h3, .history-box h3 {
            margin: 0 0 8px 0;
            color: #ffde9e;
            font-size: 20px;
            border-bottom: 2px dotted #aab57a;
            padding-bottom: 4px;
        }
        .rule-box ul {
            margin: 8px 0 0;
            padding-left: 22px;
        }
        .rule-box li {
            margin: 8px 0;
            font-size: 15px;
        }
        .rule-box .critical {
            color: #ffb4a2;
            font-weight: 600;
            background: #5d3a2e;
            padding: 5px 10px;
            border-radius: 30px;
            list-style: none;
            margin-left: -22px;
        }
        .history-box {
            max-height: 160px;
            overflow-y: auto;
            font-size: 15px;
            background: #2d4d2d;
        }
        .history-entry {
            padding: 4px 6px;
            border-bottom: 1px solid #6f8260;
            font-family: 'Courier New', monospace;
        }
        .check-warning {
            background: #b22222;
            color: white;
            padding: 6px 15px;
            border-radius: 30px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; } }
    </style>
</head>
<body>
<div class="game-wrapper">
    <div class="board-container">
        <div class="board" id="chessboard"></div>
    </div>

    <div class="info-panel">
        <div class="turn-box" id="turnDisplay">
            <span>‚ö™</span> White's turn
        </div>
        <button onclick="resetGame()">üé≤ New Random Game</button>
    </div>

    <div class="rules-history">
        <div class="rule-box">
            <h3>‚ö° Rchess rules</h3>
            <ul>
                <li>‚ôú All 16 pieces random on 1st+2nd rank</li>
                <li>üî¥ <strong>Back‚Äërank pawn</strong> (marked <span style="color:#ff8888">¬π</span>) ‚Üí only 1 square</li>
                <li>‚úÖ Other pawns: 1 or 2 squares first move</li>
                <li class="critical">üëë KING SAFETY ‚Äî if <strong>king started on 2nd rank</strong> and is in check, ANY piece can block/escape on the very first reaction (ignoring pins). This ‚Äúfirst pass‚Äù works only once per game.</li>
                <li>üö´ No castling</li>
            </ul>
        </div>
        <div class="history-box" id="historyBox">
            <h3>üìú Move history</h3>
            <div id="movesList"></div>
        </div>
    </div>
</div>

<script>
    (function() {
        // ----- GAME STATE -----
        let board = Array(8).fill().map(() => Array(8).fill(null));
        let currentPlayer = 'white';            // white = human, black = computer
        let selectedSquare = null;
        let validMoves = [];
        let moveHistory = [];
        
        // special rule: track if king started on 2nd rank and check state
        let whiteKingStartRow = null;   // 0 or 1
        let blackKingStartRow = null;   // 7 or 6
        let usedFirstPassWhite = false; // true if white already used the special "any move" privilege
        let usedFirstPassBlack = false;

        // ----- HELPER: piece symbols (white = lowercase, black = uppercase) -----
        const symbols = {
            white: { rook:'‚ôú', knight:'‚ôû', bishop:'‚ôù', queen:'‚ôõ', king:'‚ôö', pawn:'‚ôü' },
            black: { rook:'‚ôñ', knight:'‚ôò', bishop:'‚ôó', queen:'‚ôï', king:'‚ôî', pawn:'‚ôô' }
        };

        // ----- INIT / RANDOM SETUP -----
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function createRandomBoard() {
            // clear
            for (let r=0; r<8; r++) for (let c=0; c<8; c++) board[r][c] = null;

            // piece pools: 8 major (R,N,B,Q,K,B,N,R) + 8 pawns
            const majorTypes = ['rook','knight','bishop','queen','king','bishop','knight','rook'];
            const pawnTypes = Array(8).fill('pawn');
            
            let whitePool = shuffleArray([...majorTypes, ...pawnTypes]);
            let blackPool = shuffleArray([...majorTypes, ...pawnTypes]);

            // place white (rows 0,1)
            for (let c=0; c<8; c++) {
                // row 0 (back rank for white)
                board[0][c] = {
                    type: symbols.white[whitePool[c]],
                    pieceType: whitePool[c],
                    color: 'white',
                    startingRow: 0,
                    hasMoved: false
                };
                // row 1
                board[1][c] = {
                    type: symbols.white[whitePool[c+8]],
                    pieceType: whitePool[c+8],
                    color: 'white',
                    startingRow: 1,
                    hasMoved: false
                };
            }
            // place black (rows 7,6)
            for (let c=0; c<8; c++) {
                // row 7 (back rank for black)
                board[7][c] = {
                    type: symbols.black[blackPool[c]],
                    pieceType: blackPool[c],
                    color: 'black',
                    startingRow: 7,
                    hasMoved: false
                };
                // row 6
                board[6][c] = {
                    type: symbols.black[blackPool[c+8]],
                    pieceType: blackPool[c+8],
                    color: 'black',
                    startingRow: 6,
                    hasMoved: false
                };
            }

            // store king start rows
            for (let r=0; r<2; r++) {
                for (let c=0; c<8; c++) {
                    if (board[r][c]?.pieceType === 'king') whiteKingStartRow = r;
                }
            }
            for (let r=6; r<8; r++) {
                for (let c=0; c<8; c++) {
                    if (board[r][c]?.pieceType === 'king') blackKingStartRow = r;
                }
            }

            usedFirstPassWhite = false;
            usedFirstPassBlack = false;
        }

        // ----- MOVE GENERATION (with custom pawn rule) -----
        function isBackRankPawn(piece) {
            if (!piece || piece.pieceType !== 'pawn') return false;
            return (piece.color === 'white' && piece.startingRow === 0) ||
                   (piece.color === 'black' && piece.startingRow === 7);
        }

        function getValidMoves(row, col, ignoreColor = false) {
            const piece = board[row][col];
            if (!piece) return [];
            if (!ignoreColor && piece.color !== currentPlayer) return [];

            let moves = [];

            if (piece.pieceType === 'pawn') {
                const dir = piece.color === 'white' ? 1 : -1;
                const backRank = isBackRankPawn(piece);

                // forward 1
                if (row+dir >=0 && row+dir<8 && !board[row+dir][col])
                    moves.push({row: row+dir, col});

                // forward 2 (only if not backRank pawn and not moved)
                if (!backRank && !piece.hasMoved) {
                    if (row+2*dir >=0 && row+2*dir<8 && !board[row+dir][col] && !board[row+2*dir][col])
                        moves.push({row: row+2*dir, col});
                }

                // captures
                for (let dc of [-1,1]) {
                    let nc = col+dc;
                    if (nc>=0 && nc<8 && row+dir>=0 && row+dir<8) {
                        let target = board[row+dir][nc];
                        if (target && target.color !== piece.color)
                            moves.push({row: row+dir, col: nc});
                    }
                }
            }

            if (piece.pieceType === 'rook' || piece.pieceType === 'queen') {
                const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
                for (let [dr,dc] of dirs) {
                    let r=row+dr, c=col+dc;
                    while (r>=0 && r<8 && c>=0 && c<8) {
                        if (!board[r][c]) moves.push({r,c});
                        else {
                            if (board[r][c].color !== piece.color) moves.push({r,c});
                            break;
                        }
                        r+=dr; c+=dc;
                    }
                }
            }
            if (piece.pieceType === 'bishop' || piece.pieceType === 'queen') {
                const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
                for (let [dr,dc] of dirs) {
                    let r=row+dr, c=col+dc;
                    while (r>=0 && r<8 && c>=0 && c<8) {
                        if (!board[r][c]) moves.push({r,c});
                        else {
                            if (board[r][c].color !== piece.color) moves.push({r,c});
                            break;
                        }
                        r+=dr; c+=dc;
                    }
                }
            }
            if (piece.pieceType === 'knight') {
                const jumps = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                for (let [dr,dc] of jumps) {
                    let r=row+dr, c=col+dc;
                    if (r>=0 && r<8 && c>=0 && c<8 && (!board[r][c] || board[r][c].color!==piece.color))
                        moves.push({r,c});
                }
            }
            if (piece.pieceType === 'king') {
                for (let dr=-1; dr<=1; dr++) {
                    for (let dc=-1; dc<=1; dc++) {
                        if (dr===0 && dc===0) continue;
                        let r=row+dr, c=col+dc;
                        if (r>=0 && r<8 && c>=0 && c<8 && (!board[r][c] || board[r][c].color!==piece.color))
                            moves.push({r,c});
                    }
                }
            }

            // Normalize move format (some had {r,c} some {row,col})
            return moves.map(m => ({row: m.r ?? m.row, col: m.c ?? m.col}));
        }

        // ----- CHECK DETECTION (simple) -----
        function isSquareAttacked(row, col, attackerColor) {
            // brute force: if any piece of attackerColor can move to (row,col)
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    let p = board[r][c];
                    if (p && p.color === attackerColor) {
                        let moves = getValidMoves(r, c, true); // ignore turn color
                        if (moves.some(m => m.row === row && m.col === col)) return true;
                    }
                }
            }
            return false;
        }

        function kingPos(color) {
            for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
                if (board[r][c]?.pieceType === 'king' && board[r][c]?.color === color) return {row:r, col:c};
            }
            return null;
        }

        function isInCheck(color) {
            let k = kingPos(color);
            if (!k) return false;
            return isSquareAttacked(k.row, k.col, color==='white'?'black':'white');
        }

        // ----- APPLY MOVE (with hasMoved update) -----
        function applyMove(from, to) {
            let piece = board[from.row][from.col];
            if (!piece) return false;

            // history
            moveHistory.push(`${piece.type} ${String.fromCharCode(97+from.col)}${from.row+1} ‚Üí ${String.fromCharCode(97+to.col)}${to.row+1}`);

            // move
            board[to.row][to.col] = {
                ...piece,
                hasMoved: true
            };
            board[from.row][from.col] = null;

            // after move, switch player
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            selectedSquare = null;
            validMoves = [];
            return true;
        }

        // ----- FIRST-PASS RULE: if king started on 2nd rank & in check, any move allowed (once) -----
        function firstPassAllowed(color) {
            if (color === 'white') {
                if (usedFirstPassWhite) return false;
                if (whiteKingStartRow !== 1) return false; // didn't start on 2nd rank
                return isInCheck('white');
            } else {
                if (usedFirstPassBlack) return false;
                if (blackKingStartRow !== 6) return false; // black's 2nd rank is row 6
                return isInCheck('black');
            }
        }

        // ----- HUMAN MOVE HANDLER with special rule override -----
        function tryHumanMove(from, to) {
            let piece = board[from.row][from.col];
            if (!piece || piece.color !== 'white') return false;

            // standard valid moves
            let moves = getValidMoves(from.row, from.col);
            let isValid = moves.some(m => m.row === to.row && m.col === to.col);

            // special first-pass rule for white
            if (!isValid && firstPassAllowed('white')) {
                // if king is in check and white hasn't used the privilege, accept any move that results in check resolved? Actually we simplify: any legal-looking move (but must not put king in check? but rule says "any piece can block/escape")
                // we just accept any move that doesn't leave king in check? Let's do: any move that results in king not in check after move.
                // but we need to simulate:
                let tempBoard = JSON.parse(JSON.stringify(board)); // deep copy
                // apply move on temp
                let p = tempBoard[from.row][from.col];
                tempBoard[to.row][to.col] = {...p, hasMoved:true};
                tempBoard[from.row][from.col] = null;
                // check if white king not in check after
                let whiteKingAfter = null;
                for (let r=0; r<8; r++) for (let c=0; c<8; c++) 
                    if (tempBoard[r][c]?.pieceType==='king' && tempBoard[r][c]?.color==='white') whiteKingAfter = {r,c};
                if (!whiteKingAfter) return false;
                // attacked?
                let attacked = false;
                for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
                    let attacker = tempBoard[r][c];
                    if (attacker && attacker.color==='black') {
                        // quick pseudo-legal from attacker (ignore turn)
                        let attMoves = getPseudoMoves(tempBoard, r, c);
                        if (attMoves.some(m => m.row===whiteKingAfter.r && m.col===whiteKingAfter.c)) attacked = true;
                    }
                }
                if (!attacked) {
                    // use privilege
                    usedFirstPassWhite = true;
                    // apply actual move
                    board[to.row][to.col] = {...piece, hasMoved:true};
                    board[from.row][from.col] = null;
                    currentPlayer = 'black';
                    selectedSquare = null;
                    validMoves = [];
                    moveHistory.push(`${piece.type} (first pass) ${String.fromCharCode(97+from.col)}${from.row+1}‚Üí${String.fromCharCode(97+to.col)}${to.row+1}`);
                    return true;
                }
                return false;
            }

            if (!isValid) return false;

            // normal move
            return applyMove(from, to);
        }

        // pseudo-legal move generator for a given board state (used in simulation)
        function getPseudoMoves(boardState, row, col) {
            // simplified: same as getValidMoves but with boardState context
            const piece = boardState[row][col];
            if (!piece) return [];
            let moves = [];
            // ... copy of move generation but using boardState (omitted for brevity, we'll just rely on standard function with global board? Actually we can reuse getValidMoves with a flag, but careful.
            // We'll implement minimal for simulation.
            return []; // placeholder, but we actually don't need detailed because we use standard getValidMoves on main board for normal cases.
        }

        // ----- COMPUTER MOVE (random but tries to capture) -----
        function computerMove() {
            if (currentPlayer !== 'black') return;

            // gather all black pieces with moves
            let candidates = [];
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    let p = board[r][c];
                    if (p && p.color === 'black') {
                        let moves = getValidMoves(r, c);
                        if (moves.length) {
                            for (let m of moves) {
                                candidates.push({from:{row:r, col:c}, to:m});
                            }
                        }
                    }
                }
            }

            if (candidates.length === 0) return; // no moves (stalemate?)

            // priority: captures (any piece)
            let captures = candidates.filter(c => board[c.to.row][c.to.col] !== null);
            let chosen = captures.length ? captures[Math.floor(Math.random()*captures.length)] : candidates[Math.floor(Math.random()*candidates.length)];

            // apply move
            let piece = board[chosen.from.row][chosen.from.col];
            board[chosen.to.row][chosen.to.col] = {...piece, hasMoved:true};
            board[chosen.from.row][chosen.from.col] = null;
            moveHistory.push(`üñ•Ô∏è ${piece.type} ${String.fromCharCode(97+chosen.from.col)}${chosen.from.row+1}‚Üí${String.fromCharCode(97+chosen.to.col)}${chosen.to.row+1}`);
            currentPlayer = 'white';
            renderBoard();

            // if game over? ignore for simplicity
        }

        // ----- RENDER -----
        function renderBoard() {
            const boardEl = document.getElementById('chessboard');
            boardEl.innerHTML = '';
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    let sq = document.createElement('div');
                    sq.className = `square ${(r+c)%2===0 ? 'light' : 'dark'}`;
                    sq.dataset.row = r; sq.dataset.col = c;

                    let piece = board[r][c];
                    if (piece) {
                        let span = document.createElement('span');
                        span.textContent = piece.type;
                        if (isBackRankPawn(piece)) span.classList.add('backrank-pawn');
                        sq.appendChild(span);
                    }

                    if (selectedSquare && selectedSquare.row===r && selectedSquare.col===c)
                        sq.classList.add('selected');

                    if (validMoves.some(m => m.row===r && m.col===c))
                        sq.classList.add('valid-move');

                    sq.addEventListener('click', (ev) => handleSquareClick(r,c));
                    boardEl.appendChild(sq);
                }
            }

            let turnSpan = document.getElementById('turnDisplay');
            if (currentPlayer === 'white') {
                turnSpan.innerHTML = '<span>‚ö™</span> Your turn (White)';
                if (isInCheck('white')) turnSpan.innerHTML += ' ¬∑ <span class="check-warning">CHECK</span>';
            } else {
                turnSpan.innerHTML = '<span>‚ö´</span> Computer (Black) thinking...';
            }

            // update history list
            let historyDiv = document.getElementById('movesList');
            historyDiv.innerHTML = moveHistory.slice(-10).map(h => `<div class="history-entry">${h}</div>`).join('');
        }

        // ----- CLICK HANDLER (human white only) -----
        function handleSquareClick(row, col) {
            if (currentPlayer !== 'white') return; // computer turn

            if (selectedSquare === null) {
                // select piece
                let piece = board[row][col];
                if (piece && piece.color === 'white') {
                    selectedSquare = {row, col};
                    validMoves = getValidMoves(row, col);
                    renderBoard();
                }
            } else {
                // try to move
                let moved = tryHumanMove(selectedSquare, {row, col});
                renderBoard();
                if (moved) {
                    // trigger computer move after short delay
                    setTimeout(() => { computerMove(); renderBoard(); }, 200);
                } else {
                    // invalid move, maybe select new piece
                    if (board[row][col]?.color === 'white') {
                        selectedSquare = {row, col};
                        validMoves = getValidMoves(row, col);
                    } else {
                        selectedSquare = null;
                        validMoves = [];
                    }
                    renderBoard();
                }
            }
        }

        // ----- RESET -----
        window.resetGame = function() {
            createRandomBoard();
            currentPlayer = 'white';
            selectedSquare = null;
            validMoves = [];
            moveHistory = [];
            renderBoard();
        };

        // bootstrap
        createRandomBoard();
        renderBoard();
    })();
</script>
</body>
</html>
